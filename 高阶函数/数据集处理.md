## 数据集处理

JavaScript 的数组方法中包括三个高阶函数，它们提供了一套高效的接口，使程序员得以关注要处理的数据和逻辑本身，而不是将时间花费在处理过程中无关紧要的细节上。



### 映射

`map` 方法会接受用户自定义的函数，并在内部遍历数组，将每一个元素作为参数传给函数并执行。自定义函数每次执行后的返回值（包括 `undefined`）会重新组合成一个新数组。它的基本用法非常清楚：

```javascript
[1, 2, 3].map((e) => alert(e));
// 1
// 2
// 3
```

它可以简化一些通常的迭代操作。例如，我们有一个数组，需要得到里面每个数值的平方，通常使用 `for` 语句的写法像这样：

```javascript
const arr1 = [1, 2, 3, 4, 5];
let   arr2 = [];
for (let i = 0; i < arr1.length; i += 1) {
    let n = arr1[i];
    arr2.push(n * n);
}
// arr2 = [1, 4, 9, 16, 25]
```

使用 `map` ，我们可以采取更清晰的方式：

```javascript
[1, 2, 3, 4, 5].map((n) => n * n);
// [1, 4, 9, 16, 25]
```

将数组的每一项转换为数值以进行下一步处理也是常见操作，我们可以写出如下的代码：

```javascript
['1', '2', '3', '4', '5'].map((a) => parseFloat(a));
// [1, 2, 3, 4, 5]
```

显然， `parseFloat` 本身就可以直接接受数组成员，因此代码可以简化如下：

```javascript
['1', '2', '3', '4', '5'].map(parseFloat);
// [1, 2, 3, 4, 5]
```

`map` 方法的意义非常简单，但这并不是全部：`map` 实际上会往用户自定义函数中传入三个参数。

```javascript
[1, 2, 3].map((element, index, arr) => {
  alert(`元素：${element} 位置：${index} 数组：[${arr}]`);
});
// 元素：1 位置：0 数组：[1,2,3]
// 元素：2 位置：1 数组：[1,2,3]
// 元素：3 位置：2 数组：[1,2,3]
```

如果传入一个只接受一个参数的函数，它就会忽略其他参数。但是有些函数有可选的第二个甚至第三个参数，例如与 `parseFloat` 作用相似但效果却截然不同的 `parseInt`。

```javascript
['1', '2', '3'].map(parseInt)
// [1, NaN, NaN]
```

这不起作用，因为 `parseInt` 可以接受两个参数：转换的字符串和指定数字基数。当我们在 `map` 中调用 `parseInt` 时，`parseInt` 会把当前元素位置当做数字基数并进行转换，自然得到了错误的结果。不好！我们需要一个只接受一个指定参数的 `parseInt` 。

我们可以写出 `['1', '2', '3'].map((s) => parseInt(s))`，或者考虑更加优雅的方式：用一个*函数装饰器*来包裹 `parseInt` 函数，使它只接受期望的一个参数。

```javascript
const unary = (fn) => {
    if (fn.length === 1) {
        return fn;
    } else {
        return (something) => fn.call(this, something);
    }
};
```

现在我们可以写成：

```javascript
['1', '2', '3'].map(unary(parseInt))
// [1, 2, 3]
```

完成！



### 归约







### 过滤







### 条件检测





------

Note：

在 JavaScript 中，每个函数都会拥有两个方法：`apply` 和 `call`，在新标准发布以前，它们在一些地方发挥了重要作用。但现在我们已经不需要使用它们了，因此本章没有提及。了解一下这两个方法的作用与异同，并尝试阐述可以用什么方式取代这两个方法。

------

