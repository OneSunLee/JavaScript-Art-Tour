

## 闭包与工厂函数

---

### 闭包的原理

*闭包*是 JavaScript 中非常强大的特性。与离散数学中的同名概念不同，JavaScript 中的闭包是这样定义的：

> 闭包是指那些能够访问自由变量（既不是本地定义也不作为参数的那些变量）的函数。换句话说，这些函数可以“记住”它被创建的时候的环境。
>
> —— Mozilla Developer Network

闭包允许函数访问并操作函数外部的标识符。只要标识符存在于函数定义所在的作用域内，闭包就可以使函数能访问这些标识符。在这里，“作用域”指的是程序特定部分中标识符的可见性。

我们对闭包的探索将从一个简单示例开始。

```javascript
let outerValue = "窝窝头，两块钱四个";
let outerFunction = () => alert(outerValue);
outerFunction(); // "窝窝头，两块钱四个"
```

在这个示例中，我们在一个作用域中定义了变量 `outerValue` 和函数 `outerFunction`，在这里是全局作用域。然后，执行全局作用域的函数 `outerFunction`。这个函数可以“看见”、可以使用外部变量 `outerValue`。这样的代码看起来并没有什么特别之处，我们大概已经使用很多次了，但事实上我们已经创建了一个闭包！有些迷惑吗？并不奇怪。因为 `outerValue` 和 `outerFunction` 是在全局作用域中声明的，这个作用域始终存在。而 `outerFunction` 在这个作用域中是可见的，因此它可以访问到外部变量 `outerFunction`。

虽然我们已经在无意中用到了闭包，但此时闭包的优势还未展现出来。让我们再来看一个示例，结合注释思考一下闭包的角色。

```javascript
let outerFunction = "雨我无瓜";

// 声明一个空变量，稍后在后面的代码中使用
let later;
let outerFunction = () => {
    
    // 在函数内部声明一个标识符，这个标识符的作用域局限于函数内部，在外部不可访问。
    let innerValue = "有点上头";
    
    // 在函数中声明一个内部函数，这时 innerValue 处在内部函数的作用域内。
    let innerFunction = () => {
        alert(outerFunction);
        alert(innerFunction);
    }
    
    // 让外部变量 later 指向 innerFunction
    // 因为 later 处在全局作用域内，所以我们可以在外部调用这个函数
    later = innerFunction;
}

// 调用 outerFunction，这时创建了内部函数 innerFunction，
// 并让 later 的值为 innerFunction
outerFunction();
later();
```

在查看答案或亲自动手之前，我们先来预测一下会发生什么。

- 首先我们会得到一个 `"雨我无瓜"`，因为外部变量 `outerValue` 在全局作用域内，程序中处处可见。
- `outerFunction` 执行后，全局变量 `later` 指向内部函数 `innerFunction`，再调用 `later`。
- 当执行 `later`时，`outerFunction` 的作用域已经不存在也不可见了。
- 所以，`innerValue` 肯定是 `undefined`！所以我们会得到一个 `undefined`。

但实际的运行结果却是这样的：

```javascript
// "雨我无瓜"
// "有点上头"
```

也就是说，尽管 `innerValue` 看起来隐藏在一个函数的内部，但我们仍然能在外部检测到 `innerValue`。这是怎么回事呢？内部函数的作用于消失之后，为什么其内部变量还存在呢？

当在外部函数中声明内部函数时，我们不仅拥有了函数本身，还拥有了一个闭包。这个闭包不仅包含了函数的名称，还把哦哦喊了函数诞生时所处作用域中的所有标识符。当通过外部变量 `later` 调用内部函数 `innerFunction` 时，尽管其所处的作用域已经消失了，但是通过闭包，我们仍然能访问到原始的作用域。这个作用域总共包含以下标识符：

```javascript
outerFunction
later
innerFunction
innerValue
outerValue
```

只不过，因为 `innerFunction` 的名称确实已经不可见了，所以要通过 `later` “移花栽木”似地调用。

这就是闭包。闭包像一个时光胶囊，保存了函数被创建时所处作用域内的各种标识符，因此函数获得了执行时所需的内容。这个时光胶囊与函数同呼吸共命运，只要函数存在，它就一直会存在。

闭包的实际结构无法在代码中查看，我们只能通过了解其原理来使用闭包。每一个通过闭包访问外部标识符的函数都拥有一条*作用域链*，作用域链包含了闭包支持函数运行所需的全部信息。由于总是要存储外部标识符，使用闭包会对于程序运行的性能有轻微损耗。因此，虽然闭包是有用的，但是不能过度使用。使用闭包时，所有的标识符和它们的值都会存储在内存中，直到浏览器确保这些信息不再使用或是页面关闭时，才会清理这些信息。这个过程称为*垃圾回收*（ Garbage Collection，GC）。





### 工厂函数



