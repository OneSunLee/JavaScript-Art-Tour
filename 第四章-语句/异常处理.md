## 异常处理

------

无论我们多么精通编程，有时我们的程序仍会不可避免的遭遇到一些错误，可能单纯是我们的程序编写出错，或是接收到了与我们预期不符的用户输入，或者是其它什么原因。通常，一段代码会在出错的时候停止执行，如果只是一个用于练习的小程序可能及时排查出问题倒没什么，但如果实在一个监测生命健康，或是多人网络游戏中，程序一旦因为遇到异常而停止执行，会造成难以预料的不良后果。JavaScript 提供了一种*`try...catch` 语句*，它会在捕捉到异常的同时不会使代码停止执行，还能根据得到的异常信息做一些更为合理的操作。



### 语法

`try...catch` 结构由两部分组成：`try` 和 `catch`：

```javascript
try {
    // 代码...
} catch (e) {
    // 处理异常
}
```

它按照以下步骤执行：

- 首先，执行 `try` 子句中包含的代码。
- 如果执行过程中没有异常，那么忽略 `catch` 子句里面的代码，try 子句执行完之后离开这个 `try...catch` 语句去做其他事情。
- 如果执行过程中发生异常，控制流就转移到了 `catch` 子句的开头。变量` e`是一个包含了异常信息的对象，也可以取其它名称，但是 `e` 可以看做 `error`（错误）或`exception`（异常）的缩写。

![img](assets/640.webp)



> 图片来源：https://mmbiz.qpic.cn/

所以，发生在 `try`子句的异常不会使代码停止执行：我们可以在 `catch` 子句里处理异常。





### try...catch 语句的使用

让我们来看更多的例子。

没有异常的例子：

```javascript
try {
    alert("开始运行 try 子句");
    // ...这里没有异常
    alert("try 子句运行完毕");
} catch (err) {
    alert("没有任何异常，catch 子句被忽略了");
}
alert("现在继续执行");
```

包含异常的例子：

```javascript
try {
    alert("开始执行 try 子句");
    lalala; // 异常，变量未定义！
    alert("try 子句执行完了");  // (2)
} catch(err) {
    alert("捕捉一只异常！");
}
alert("现在继续执行");
```

要使得 `try...catch `能工作，代码必须是可执行的，换句话说，它必须是有效的 JavaScript 代码。

如果代码包含语法错误，那么` try...catch` 不能正常工作，例如含有未闭合的大括号：

```javascript
try {
    {{{{{{{{{{{{
} catch(e) {
    alert("这不是合法的代码，这段 catch 子句也不会被执行");
}
```

浏览器读取然后执行代码，发生在读取代码阶段的异常被称为*解析时错误*（parse-time），`try...catch` 也对它们无可奈何，因为这样的代码浏览器就读不懂，也就无法理解 `try...catch` 语句。`try...catch` 只能处理有效代码之中的异常。这类异常被称为*运行时错误*（runtime errors），有时候也称为 “`exceptions`”。

当一个异常发生之后，JavaScript 生成一个包含异常细节的对象。这个对象会作为一个参数传递给 `catch`：

```javascript
try {
    // ...
} catch(e) {
    // “异常对象”，可以用其他参数名代替
    // ...
}
```

对于所有内置的异常，`catch` 子句捕捉到的相应的异常的对象都有两个属性：

`name` ：异常名称，对于一个未定义的变量，名称是 “ReferenceError”

`message` ：关于异常的文字描述。

还有很多非标准的属性在绝大多数环境中可用。其中使用最广泛并且被广泛支持的是：

`stack` ：当前的调用栈。它是用于调试的，一个包含引发异常的嵌套调用序列的字符串。

例如：

```javascript
try {
    lalala; // 异常，变量未定义！
} catch(err) {
    alert(err.name);    // ReferenceError
    alert(err.message); // lalala 未定义
    alert(err.stack);   // 异常捕获过程的细节
    alert(err);         // ReferenceError: lalala 未定义
}
```





### 异常处理的应用

让我们一起探究一下真实使用场景中 `try...catch` 的使用。

在前面的章节中，我们了解过质数判断算法，并编写了一个循环接收用户输入并给出判断结果的程序。我们对用户输入进行了检查，如果符合要求，那么往后执行；否则的话，会给出一个错误信息并终止程序。由于是在一个 `while` 语句的循环体内，直接使用 `break` 语句就能达到终止程序的目的。但是`break`语句的本意是“停止循环“，而非“中止程序”，如果不是在循环内运行，就不能使用 `break` 语句，此外，在 `break` 语句之前还需要告知用户遇到的问题。

遇到不合法输入的问题本质是“处理异常”，而非“结束程序”，因此我们的程序应该拥有一个处理异常的机制，同时将“遇到异常，暂停程序”和“告知用户遇到的异常”优雅地结合在一起。前一个需求我们已经有了 `try...catch` 语句，而对于后一个，另一种语句可以做到：*`throw` 语句*。它可以*标记*一个异常信息，称为*抛出异常*。它的语法如下所示：

```javascript
throw 表达式;
```

当遇到 `throw` 语句的时候，程序暂停执行后面的内容，带着表达式的值一层一层地退出控制流，直到遇到外层的 `try` 子句。如果没有 `try` 子句包裹可能会抛出异常的语句，那么异常信息就会被直接告知浏览器，整个程序也就真正停止运行了。我们用一个示例来观察一下 `throw` 语句与 `try..catch` 语句的搭配使用。

```javascript
try {
    alert("一二三四五，上山打老虎");
    throw "老虎来了";
    alert("老虎没打到，打到小松鼠");
} catch (e) {
    alert(e);
}
```

这段代码在输出 `"一二三四五，上山打老虎"`之后，遇到了 `throw` 语句，就暂停执行后面的内容。程序带着 `"老虎来了"` 的信息逃离现场，遇到 `try` 子句，就相当于吃了一记定心丸，带着强大的武器去捕捉老虎，便开始执行 `catch` 语句，同时捕获了`"老虎来了"`的异常信息，并输出它。如果 `throw` 语句的处于其它语句内部，也会使程序执行到这里就带着异常信息撤退，倘若遇到了 `try` 语句，就说明这个异常被捕获了，异常信息作为异常对象被传递给 `catch` 子句的括号里绑定的变量。

有了 `throw` 语句和 `try...catch` 语句搭配使用，程序便有了强大的异常处理机制，即便遇到“未知的危险”也可临危不惧，异常已经被抓在了 `catch` 子句的手心里，正常执行程序时也不会因可能遇到的异常而手忙脚乱。利用异常处理机制，我们来改写一下前面的质数判断程序。

```javascript
let n = parseInt(prompt("请输入一个大于 1 的正整数。"));
while (true) { // 循环接受输入。
    try {
        if (isNaN(n) || !isFinite(n) || n <= 1) {
            throw "输入不符合要求，程序停止";
        }    
        let isPrime = (n === 2) || (n % 2 !== 0);
        for (let i = 3, last = Math.sqrt(n); i <= last; i += 2) {
            if (n % i === 0) {
                isPrime = false;
                break; // 这个 break 语句只退出当前所在的循环。
            }
        }
        alert(`${n}是一个${isPrime ? "质数" : "合数"}`); // 使用模板字符串来拼凑信息
        n = parseInt(prompt("请输入一个大于 1 的正整数。"));
    } catch (e) {
        alert(e);
    }
}
```

原先的版本中，程序一旦接受到了不符合要求的用户输入，就会退出循环，也就停止了程序；而这里用异常处理机制改写之后，即使遇到异常，程序只会跳过这一轮的正常处理，直接告知用户，程序依然保持运行，同时“抛出”——“捕获”异常的语义性也远比原先的“输出信息”“跳出循环”要清晰得多。充分利用异常处理机制，我们能够写出更加优雅和*健壮*的代码。对于不可预知的异常输入而仍然能保持正常运行，并将信息及时展现给用户，这种性质被称为程序的*鲁棒性*。





### 异常对象

