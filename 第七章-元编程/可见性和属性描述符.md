## 可见性和属性描述符

---

### 可见性

JavaScript 世界里有一家银行。Yukihiro 写了本书，拿到出版社给的 200 块钱，决定把它存起来。他开了一个账户，并把 100 块钱存了进去。这个账户的基本信息是拥有者的名字和账户余额，我们很容易就能写出一个对象来描述。它是一个账户，不应该变成别的什么东西，因此我们用 `const` 来声明它。

```javascript
const account = {
    owner: "Yukihiro",
    balance: 200
};
```

一个银行账户能做什么？它可以存入，也可以取走一些钱，当然取走的钱不能多于账户的余额。“存入”和“取出”的操作，自然就作为了账户对象的方法。对象添加了这两个方法后是这个样子：

```javascript
const account = {
	owner: "Yukihiro",
	balance: 200,
	save(value) {
		this.balance += value;
		return this.balance;
	},
	withdraw(value) {
		if (this.balance < value) {
			alert("余额不足");
			return 0;
		}
		this.balance -= value;
		return value;
	}		
};
```

Yukihiro 去大阪演讲，又拿了 120 元酬劳。既然账户对象可以存钱和取钱了，他就把钱存了进去，需要的时候再取用。

```javascript
alert(account.save(120));     // 220
alert(account.withdraw(50));  // 50
account.save(200);
account.withdraw(500);        // "余额不足"
alert(account.balance);       // 370
```

经过一番存取，Yukihiro 的账户余额还有 370 元钱，他离开了银行。随后，一个叫 Mochizuki 的数学家也来银行存钱了。我们可以为 Mochizuki 按照原来的样子重新建造一个账户，但我们也可以建立一个账户类，以后所有账户对象都可以快捷地随用随开。银行改革了开户的方式之后，Yukihiro 也重开了一个账户，然后是 Mochizuki。

```javascript
class Account {
	constructor(owner, balance = 0) {
		this.owner = owner;
		this.balance = balance;
	}
	save(value) {
		this.balance += value;
		return balance;
	}
	withdraw(value) {
		if (this.balance < value) {
			alert("余额不足");
			return 0;
		}
		this.balance -= value;
		return value;
	}
};

let account1 = new Account("Yukihiro", 100);

alert(account1.balance);   // 170
account1.balance = 1000;   // 账户余额被不法分子篡改了！
account1.withdraw(500);    // 500 元钱凭空出现在了不法分子的手上
alert(account1.balance);   // 500

let account2 = new Account("Mochizuki");
alert(account2.balance);   // 0
account2.balance = account1.withdraw(account1.balance); // Mochizuki 如法炮制
                                                        // 拿走了 Yukihiro 所有的存款
alert(account2.balance);   // 500
```

Yukihiro 的新账户刚刚开完，他的余额就被人修改了，账户里凭空多出了 900 元！这看起来是一件好事。但事实上 Yukihiro 的账户成了不法分子的小白鼠，只要随便写一个余额的数字，钱就到手了。这不仅让 Yukihiro 摸不着头脑，如果所有人都发现了这个秘密，那么长此以往，JavaScript 世界的经济岂不是要乱套！问题的根源就在于，账户的余额被记录在账户对象的 `balance` 属性上，但这个属性是公开的，任何人都可以随意访问和修改。为了避免这种问题，我们尝试改变一下策略：

```javascript
const Account = (owner, balance = 0) => {
	let theBalance = balance;
	const account = {
		owner: owner,
		save(value) {
			theBalance += value;
			return theBalance;
		},
		withdraw(value) {
			if (theBalance < value) {
				alert("余额不足");
				return 0;
			}
			theBalance -= value;
			return value;
		}
        // 还需要一个访问账户余额的方法
        getBalance() {
            return theBalance;
        }
	};
	return account;
};

const account1 = Account("Yukihiro", 100);
// 现在就不用担心余额被直接篡改了
alert(account1.theBalance);   // undefined
alert(account1.getBalance()); // 100
account1.withdraw(200);       // "余额不足"
alert(acount1.save(150));     // 250
```

我们使用了一个*工厂函数*（factory function）替代类来批量建立账户。它就像一个生产对象的工厂，把生产过程中的细节隐藏起来，只对外输出对象的成品。账户不再拥有公开的 `balance` 属性，余额被记录在工厂函数的内部变量 `theBalance` 上，外部无法直接访问或者修改。为了方便起见，账户对象还要有一个 `getBalance` 属性来查看余额。

现在最基础的安全措施已经有了。来银行开户的人越来越多，银行很快发现另一个问题：`withdraw` 作为取钱的方法，它是可以随意使用的。如果别有用心的人直接访问别人账户，取走别人的钱怎么办？办法很快就有了：使用**密码**。

在现实生活中，无论是在网上注册，还是在银行开户，都会设置一个密码。这个密码往往可以更改，但是要先用原密码验证。如果说账户余额只是不能公开修改权，而访问权则无所谓，那么密码的访问权自然是严格保密的。我们更新这个工厂函数，增加对密码的支持。

```javascript
const Account = (owner, password, balance = 0) => {
	if (!owner || !password) {
		alert("请输入用户名和密码！");
		return null;
	}
	let theBalance = balance;
	let thePassword = password;
	const account = {
		owner: owner,
		save(value) {
			theBalance += value;
			return theBalance;
		},
		withdraw(value, password) {
			if (password != thePassword) {
				alert("密码错误");
				return 0;
			}
			if (theBalance < value) {
				alert("余额不足");
				return 0;
			}
			theBalance -= value;
			return value;
		},
		// 修改密码的方法
		changePassword(oldPassword, newPassword) {
			if (!oldPassword || !newPassword) {
				alert("请输入正确的密码");
				return 0;
			}
			thePassword = newPassword;
		}
	};
	return account;
};
```

对密码的处理与对账户余额数据相同，同时不再提供对密码的访问方式，密码作为一个变量，只存在于内存中和用户的心中。接下来我们来愉快地测试一下这个更新了的工厂函数。

```javascript
const account1 = Account("Yukihiro", "mats", 100);
alert(account1.theBalance);              // undefined
account1.withdraw(200);                  // "密码错误"
account1.withdraw(200, "mats");          // 把密码设置为 "mats"
alert(account1.save(150));               // 250
account1.changePassword("mats", "stam"); // 更改密码，并使用原密码验证
account1.withdraw(50, "mats");           // "密码错误"
alert(`取款：${account1.withdraw(50, "stam")}元`); // "取款50元"
```

在本小节的示例中，我们利用工厂函数来创建对象，是出于对*信息隐藏*的考虑。JavaScript 所提供的普通属性容易被篡改，因此我们将重要的、不应被外部随意访问或更改的数据，利用闭包存储在函数作用域内，以达到实现*私有属性*的目的。

在面向对象编程的概念中，私有属性是对象封装的基础。由于 JavaScript 一直以来没有在语法上为私有属性提供支持，有时程序员们会使用一种约定，以下划线 `"_"` 开头的属性名称作为私有属性，从外部访问对象时就不去触碰以这类方式命名的属性。但闭包中的私有变量从源头带来保障，不必依赖非强制性的约定。工厂函数作为闭包的使用方式，将可公开的属性与方法与私有的属性与方法分开，尽管这种方式并不是十分优雅（在典型的面向对象语言中看不到这种方式），但它确实是一个良好的实践。在代码规模大量增长之后，面对许多需要妥善保存和隐藏的数据，工厂函数的好处就逐渐凸显出来。在此基础上，人们将代码划分为语义上的*模块*（详见第八章），并进一步诞生了更高级的思想。

而在接下来的小节中，我们将开辟新的思路，越过基础的籓篱，在对数据的控制上更进一步，更充分地利用 JavaScript 本身的语言特色，避开对不足之处的弥补手段。我们将对程序本身进行编程，发掘我们从未接触过的领域。





### 属性描述符

我们对 JavaScript 中*元编程*的探讨将从本小节正式开始。首先，让我们定义“元编程”一词。

> 元编程（英语：Metaprogramming）是指某类计算机程序的编写方式，这类计算机程序编写或者操纵其它程序（或者自身）作为它们的数据，或者在运行时完成部分本应在编译时完成的工作。

基本上，任何可以对您的程序起作用，修改它或使用自己的结构作为数据的东西都可以被认为是元编程。





### 访问器与设置器







### 对象的控制

（1）冻结对象

`Object.freeze` 方法可以*冻结*对象，以防止它被更改。被冻结的对象不能加入新的属性，已有的属性也不能被删除或者修改值。`Object.isFrozen` 查看一个对象是否被冻结。

```javascript
// 可乐的包装和成分
const cola = {
    wrapping: ["plastic", "aluminum"],
    composition: ["water", "essence", "sugar", "carbonate"]
};

alert(Object.isFrozen(cola)); // false
delete cola.wrapping;
alert(cola.wrapping);         // undefined

// 现在冻结它
Object.freeze(cola);
delete cola.composition;
alert(cola.composition);      // water,essence,sugar,carbonate
alert(Object.isFrozen(cola)); // true
```

（2）密封对象

*密封*（sealing）一个对象，意味着不能添加新的属性，已有的属性被标识为不可配置（nonconfigurable）的。但是这与冻结对象不同，已有的属性仍然可以修改。`Object.seal` 执行密封操作，而 `Object.isSealed` 判断一个对象是否被密封。

```javascript
const company = {
    name: "Tanpero",
    members: 120
};
alert(Object.isSealed(company)); // false
Object.seal(company);
alert(company.name);             // "Tanpero"
company.name = "Orepnat";
company.boss = "Jack";
alert(company.name);             // "Orepnat"
alert(company.boss);             // undefined
```



（3）阻止扩展对象

![freezeSealAndPreventExtensions](assets/freezeSealAndPreventExtensions.png)



