## 类和继承

---

### 类与原型

设想一下，现在我们是一家汽车经销商，拥有随时待命的工厂。每当我们经手一辆新的汽车，我们就可以写出一个汽车对象，拥有它自己的属性。

```javascript
let car = {
    brand: "Honda Civic",
    color: "blue"
};
```

如果只有寥寥几辆的汽车需求，那么这种办法尚可接受；但是，如果汽车订单多了起来，我们恐怕不能像这样一辆辆手工生产。JavaScript 赋予了我们一种机器，可以根据设计图纸批量生产出汽车——想要多少就有多少！

我们知道，每辆汽车都属于“汽车”这类产品，同时所有的汽车都会拥有自己的 `brand` `color` 属性，我们可以制定好汽车产品的原型，每次生产时只需要说明它的品牌与颜色。现在是时候掀开这台神奇机器的面纱了！

```javascript
class Car {};
```

嘿，等等，这是什么！`class` 是做什么的？

其实， `class` 是一个新的关键字，用于表示“一类”什么东西，用 JavaScript 的话说，是*定义了一个类*。 `Car` 就是这个类（“这类东西”）的名称，一般使用大写字母开头，这里我们定义了 `Car` 这个类以表示汽车。其后的大括号将会包含生产汽车所需要的一些工具。

有了 `Car` 类，我们就可以开动机器快速生产出一辆新的汽车。

```javascript
let car = new Car();
```

这个写法是不是有些眼熟？我们在第三章中接触过。在第三章中，我们了解到： `new` 关键字用于*生成一个构造器的实例*，在这里 `Car` 就承担了构造器的作用，我们写下 `new Car()` ，也就相当于拥有了一辆新的汽车。

但是，我们会发现这个新的汽车并没有 `brand` 和 `color` 属性。

```javascript
alert(car.brand); // undefined
alert(car.color); // undefined
```

所以，仅仅写出 `class Car` 是不够的，我们需要画好设计草图，说明这类汽车将会拥有什么属性。我们可以在 `Car` 类中写出一个名为 `constructor` 的*方法*。

```javascript
class Car {
    constructor (brand, color) {}
};
```

这个 `constructor` 又是做什么的呢？它就是我们将来每次生产汽车时所遵循的设计草图。它是一个特殊的方法，称为*构造函数*。就像这个名字所提示的那样，它的作用是构造一个对象。在构造一个汽车对象时我们需要做什么呢？当然是确定它的牌子与颜色。

```javascript
class Car {
    constructor (brand, color) {
        this.brand = brand;
        this.color = color;
    }
};
```

现在，我们再来生成新的汽车对象。

```javascript
let car = new Car("Honda Civic", "blue");
alert(car.brand); // "Honda Civic"
alert(car.color); // "blue"
```

现在它是一辆拥有自己的属性的汽车了！我们只需要将它的品牌和颜色值当做构造函数的参数，多么容易！

现在回来看 `Car` 类的定义。它的构造函数 `constructor` 接受两个参数 `brand` 和 `color`，分别对应品牌和颜色。其后两行代码的含义是：将汽车的 `brand` 和 `color` 属性设置为参数 `brand` 和 `color` 的值。

在类的定义中，**`this` 关键字表示将会构造的对象本身，它的属性表示对象将会拥有的属性。**

也就是说，当我们写下 `this.xxx = yyy` 时，我们就说明了将来生成的对象的 `xxx` 属性的值会是 `yyy`。我们还记得第三章中引入的概念——“实例”和“实例化”——吗？现在我们可以阐述一下类所发挥的作用了。

首先，`Car` 是一个类，它拥有一个构造函数。当我们像这样：`new Car("any", "any")` 实例化一个类时，我们会接受一些参数，实际上调用了类的构造函数，并在构造函数中完成了完成了构造一个对象所需做的事情。

在 JavaScript 中，一个类是一种特殊的函数。但是它不能像通常的函数那样直接调用。

```javascript
new Car("Unknown", "black"); // OK
Car("Unknown", "black");     // TypeError: Class constructor Car cannot be invoked without 'new'
```

除了 `constructor` 之外，类还可以拥有其它的方法，它们的形式像在对象字面量中一样，不过应该省略逗号。

```javascript
class Car {
    constructor (brand, color) {
        this.brand = brand;
        this.color = color;
    }
    toString () {
        return `This car's brand is ${this.brand} and its color is ${this.color}.`;
    }
}
let car = new Car("Byd Auto", "silver");
alert(car.toString()); // "This car's brand is Byd Auto and its color is silver."
```

所有的类都具有一个 `prototype` 属性，它是所有实例的原型，原型的属性和方法就是实例的属性和方法。在一个类中， `this` 关键字实际上指这个原型。我们可以通过手动为原型的属性赋值，来达到相同的目的。

```javascript
class Car {};
Car.prototype.model = "Unkonw"; // 默认
Car.prototype.color = "black";  // 默认
Car.prototype.constructor = (model, color) => {
    this.model = model;
    this.color = color;
};
let car = new Car("Saic Motor", "black");
alert(car.model); // "Saic Motor"
alert(car.color); // "black"
```

类的定义则是上述方式的简化写法。





### 继承







### 原型链







