## 高阶函数

---

### 一等公民

JavaScript 中的函数素来有“一等公民”的称呼，这来源于函数在 JavaScript 中的地位。它们都是值，也就是说，可以作为其它函数的参数或者返回值。它们也都是对象，称为“函数对象”，可以拥有自己的属性与方法。

对其他函数进行操作的函数称为*高阶函数*，它接受其他函数作为参数或返回另一个函数本身。高阶函数在许多地方发挥着重要作用，例如，当我们要遍历一个数组并对其中的数据进行自动处理，例如将每个元素转换为大写，我们可能会这样写：

```javascript
const arr = ["a", "b", "c", "d", "e", "f", "g"];
for (let i = 0, last = arr.length; i < last; i += 1) {
    arr[i] = arr[i].toUpperCase();
}
alert(arr); // A,B,C,D,E,F,G
```

应用高阶函数，我们可以用更优雅的方式实现：

```javascript
arr.forEach((el, i) => {
    arr[i] = el.toUpperCase()
});
alert(arr); // A,B,C,D,E,F,G
```

这里使用了数组的 `forEach` 方法，它接受一个函数作为参数，并遍历数组的每一项元素，将每次遍历的元素和索引，作为参数，来调用传入的函数。这样的写法可比使用 `forEach` 手动循环简单优雅得多。

另一种常见的应用是数组的 `sort` 方法。默认情况下，当我们直接调用 `sort` 方法时，会根据字典序对数组的每一项进行排序。但我们也可以自定义一个比较函数，来规定排序所使用的的规则，它将会得到两个参数，代表实际排序时每次比较的两个元素，并需要返回一个值，作为先后顺序的判断依据。

假设这个比较函数名为 `compare` ，并且 `a` 和 `b` 分别是两个相互比较的元素，那么：

- 如果 `compare(a, b)` 小于 0，那么 `a` 应该在 `b` 的前面 。
- 如果 `compare(a, b)` 等于 0，那么 `a` 和 `b` 的相对顺序不变。
- 如果 `compare(a, b)` 大于 0，那么 `b` 应该在 `a` 的后面。
- 对于两个不变的 `a` 和 `b` ，那么 `compare` 函数应该返回相同的值，否则排序结果是无法预料的。

我们可以简单地写出 `compare` 函数。

```javascript
const compare = (a, b) => a - b;
```

使用这个 `compare` 函数，会使得数组中的数字依照大小顺序排列，而不是字典顺序。

```javascript
const numbers = [42, 7, 15, 6, 0, 20, 9, 83];

// 默认比较方式
alert(numbers.sort());        // 0,15,20,42,6,7,83,9

// 重新定义的比较方式
alert(numbers.sort(compare)); // 0,6,7,9,15,20,42,83
```

使用自定义的 `compare` 函数，我们还可以处理更加复杂的排序情况。例如，我们有一个数组，包含了一些名称和它们的对应值。我们既可以根据名称的字典顺序排列，也可以根据它们的对应值从小到大排列。

```js
const items = [
    { name: 'Edward', value: 21 },
    { name: 'Sharpe', value: 37 },
    { name: 'And', value: 45 },
    { name: 'The', value: -12 },
    { name: 'Magnetic', value: 13 },
    { name: 'Zeros', value: 37 }
];

// 根据 value 属性从小到大排列
items.sort((a, b) => a - b);

// 根据 name 属性依照字典顺序排列
items.sort((a, b) => {
    let nameA = a.name.toUpperCase(); // 忽略大小写
    let nameB = b.name.toUpperCase(); // 忽略大小写
    if (nameA < nameB) {
        return -1;
    }
    if (nameA > nameB) {
        return 1;
    }

    // 两个 name 相等
    return 0;
});
```



---

练习 5.5.1

1. 使用 `forEach` 方法，尝试显示出排序后的 `item` 每一项的内容。
2. 思考生活中有哪些更复杂的排序需求，并尝试写出相应的比较规则。

---





### 数据集处理

1. **map**







2. **reduce**







3. **filter**





---

Note：

在 JavaScript 中，每个函数都会拥有两个方法：`apply` 和 `call`，在新标准发布以前，它们在一些地方发挥了重要作用。但现在我们已经不需要使用它们了，因此本章没有提及。了解一下这两个方法的作用与异同，并尝试阐述可以用什么方式取代这两个方法。

---





### 抽象化

在本章的开始部分，我们阐述过：函数的一大作用是将重复的操作封装起来，使我们只需要关心处理的值本身，而不需要关心计算的细节。当我们完成操作时，可能会依赖某些特定的值。由于函数将操作的逻辑提取出来，使它减少了对特定的值的依赖，也就增大了应用程序的灵活性。

我们再次温习一下这个使用函数来减少对特定值的依赖的过程。

```javascript
// 一开始的写法
let arr = [];
for (let i = 0; i <= 20; i += 1) {
    arr.push(i);
}
alert(arr); // 0,1,2,3,4,5,6,...20

// 使用函数后的写法
const repeatPush = n => {
    let arr = [];
    for (let i = 0; i <= n; i += 1) {
        arr.push(i);
    }
    return arr;
};

alert(repeatPush(20)); // 0,1,2,3,4,5,6,...20
```

我们将“记录$$N$$个值”这一操作提取出来作为一个单独的函数，换句话说，我们把“记录$$N$$个值”*抽象化*了。但是，如果我们想要做除了“记录$$N$$个值”以外的事情呢？由于“做某事”可以表示为函数，而函数只是值，我们可以将操作作为另一个函数值传递给 `f` 。

```javascript
const repeat = (n, action) => {
    for (let i = 0; i <= n; i += 1) {
        action(i);
    }
};

repeat(3, alert);
// 1 → 2 → 3
```

我们注意到 `repeat` 这个函数名称的变化——它不再依赖特定的操作，因此它的名称也就具有更大的抽象性。

我们不必将预定义好的函数传给 `repeat`，现场定义要进行的操作也不失为好办法。

```javascript
let labels = [];
repeat(5, n => {
    labels.push(`${n}号小可爱`);
});
alert(labels);
// 0号小可爱,1号小可爱,2号小可爱,3号小可爱,4号小可爱,5号小可爱
```

高阶函数允许我们抽象操作，而不仅仅是值。它们有多种形式。例如，我们可以写出创建新函数的函数。

```javascript
const greaterThan = n => {
    m => m > n;
};
const greaterThan10 = greaterThan(10);
alert(greaterThan10(12)); // true
alert(greaterThan10(6));  // false
```

我们还可以拥有改变其他函数的函数。

```javascript
const noisy = f => {
    return (...args) => {
        alert(`call with ${args}.`);
        let result = f(...args);
        alert(`call with ${args}, return ${result}.`);
        return result;
    };
};

noisy(Math.min)(8, 6, 3);
// call with [8, 6, 3].
// call with [8, 6, 3], return 1.
```

利用函数对操作流程的封装，我们甚至可以用自定义控制流。如下的 `unless` 函数是 `if` 语句的相反形式，而 `repert` 则对应于 `for`。

```javascript
const unless = (test, then) => {
    if (!test) {
        then();
    }
};
repeat(5, n => {
    unless(n % 2 === 1, () => alert(n + "是偶数"));
});
// 0 是偶数
// 2 是偶数
// 4 是偶数
```







### 柯里化





### 函数重载

```javascript
let addMethod = (object, name, fn) => {
  
	//保存原有的函数，因为调用的时候可能不匹配传入的参数个数
	let old = object[name];
  
	//创建一个新匿名函数作为新方法
	object[name] = (...args) => {
    
        //如果该匿名函数的形参个数和实参个数匹配，就调用该函数
        if (fn.length === args.length) {
            return fn(...args);
            
         //如果传入的参数不匹配，则调用原有的参数
        } else if (typeof old === 'function') {
            return old(...args);
        }
    }
}
```



